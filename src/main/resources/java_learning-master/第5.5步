5.5 这时候应该已经涉及了Java的垃圾回收。要留意即使有垃圾回收的情况下也会发生的内存泄露（如自己设计数组容器，元素是引用，逻辑上删除了元素，
但并没有清成null）。注意垃圾回收只能回收内存中的对象，除了内存以外，其它资源不能依靠垃圾回收来关闭。比如，文件、管道、Socket、数据库连接等，
垃圾回收是不会帮你关闭的。
本章内容主要是内存管理和垃圾回收机制参考，参考资料主要为《深入理解java虚拟机》的前三章和部分《java高手真经》
首先是内存管理：主要包括java内存区域的介绍和内存溢出异常
开始----------------------------------------------------|
|                   此为运行数据区                       |
|    方法区           虚拟机栈         本地方法栈         |
|                                                       |
|                                                       |
|    堆                      程序计数器                  |
|                                                       |
|-------------------------------------------------------|
       ^  |                         ^  |
       |  v                         |  v
    执行引擎        ->              本地库接口      ->          本地方法库
    
    所有线程共享的数据区: 方法区、堆、执行引擎、本地库接口
    线程隔离的数据区（各线程私有的）：虚拟机栈、本地方法栈、程序计数器。
    
    上述为java虚拟机运行时的数据区
    
    一、下面我来一个个介绍：
    (1)程序计数器:各线程私有的，书上的说法：它可以看作是当前线
                 程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器
                 工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这
                 个计数器来完成。
                 我来解释一下，我们都知道多线程并发是指线程轮流切换，轮流使用控制器，通过分配控制器的时间来实现的，比如说1秒内，多少毫秒给这个线程
                 多少毫秒给那个线程，如此实现多线程。在某一时刻内，控制器只能处理一个线程。
                 当线程切换，最后又回来时，控制器怎么知道这个线程进行到哪一步了，即上次执行到第几行指令，这次从哪开始，这时程序计数器发挥作用，其能
                 使得回到正确的执行位置。
                 也因此程序计数器是各线程所私有的。
    (2)java虚拟机栈:java虚拟机栈也为线程所私有，虚拟机栈描述的是java方法(敲黑板，注意是方法)执行的内存模型：每个方法在执行的同时
                   都会创建一个栈帧（Stack Frame[1]）用于存储局部变量表(重点)、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，
                   就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。栈帧是方法运行时的基础数据结构
                   通常人们所讨论的把虚拟机内存区分成堆和栈两个部分，栈就是虚拟机栈，或者说虚拟机栈中的局部变量表。
                   局部变量表存储的内容:编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，
                                      它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和
                                      returnAddress类型（指向了一条字节码指令的地址）。
                   局部变量表，其所需的内存在编译期间已经确定，进入一个方法时，这个方法在帧中分配多大的局部变量空间已经确定，方法在运行期间不会改变局部变量表
                   的大小。
                   
                   虚拟机栈这个部分可能会出现两个异常：(1)当线程申请的栈深度大于虚拟机所允许的深度，则会跑出stackoverflowerror异常(2)对于大部分可动态扩展
                   的虚拟机栈，如果扩展时无法申请到足够的内存，则会抛出outofmemoryerror异常。
    (3)本地方法栈：其重用与虚拟机栈相似，二者区别是虚拟机栈为虚拟机执行java方法服务，而本地方法栈为虚拟机执行native方法服务
                  native方法:简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java
                  语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern "C"告知C＋＋编译器去调用一个C的
                  函数。对于native方法而言，Java程序不会为该方法提供实现体。
                  例子：
                  public class NativeTest{  
                     public native void info();  
                  } 
    (4)java堆:注意堆与栈的区别。
              java堆是虚拟机栈中所占内存最大的一块，它是所有线程共享的一块内存区域，虚拟机启动时创建，其唯一(敲黑板，注意啦)目的是存放对象实例，
              几乎所有的对象实例都在这里分配内存。
              规范上说；所有的对象实例和数组都在堆上分配内存。
              垃圾回收主要是回收对象实例所占的内存，用暖神的说法：注意垃圾回收只能回收内存中的对象，除了内存以外，其它资源不能依靠垃圾回收来关闭。
              比如，文件、管道、Socket、数据库连接等，垃圾回收是不会帮你关闭的。所以java堆是垃圾收集器管理的主要区域。
              java堆的一般特性:Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固
                              定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存
                              完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。
    (5)方法区:各个线程所共享的区域。其用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
              Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。
              相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要
              是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域
              的回收确实是必要的。
    (6)运行时常量池:注意，运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常
                   量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池
                   中存放。
                   首先我们先来看看常量池的信息：Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。
                   所谓静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，
                   占用class文件绝大部分空间。
                   而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，
                   就是指方法区中的运行时常量池。
                   常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。除了包含代码中所定义的各种基本类型（如int、long等等）
                   和对象型（如String及数组）的常量值(final)(敲黑板，常量值才是重点，各种基本类型和对象型的常量值，不是基本类型和对象型，
                   此二者存在虚拟机栈中的局部变量表中)还包含一些以文本形式出现的符号引用，比如：类和接口的全限定名； 字段的名称和描述符； 
                   方法和名称和描述符。虚拟机必须为每个被装载的类型维护一个常量池。
                   可能会和虚拟机栈有些冲突误会：虚拟机栈保存的主要是局部变量表，用于描述方法执行的内存模型，而运行常量池保存的是被保存在
                   已编译的.class文件中的一些数据。
    (7)直接内存
              直接内存并不是java虚拟机运行数据区的一部分，但是这部分内存也被频繁地使用，
              在JDK1.4以后加入了NIO(new input/output)类，引入了基础通道（Channel）与缓冲区（Buffer）的I/O方式，这种方法使得native函数库
              直接分配堆外内存(直接内存)，然后通过java堆中的一个DirectByteBuffer对象作为这块内存的引用进行操作，从而避免了java堆和native堆
              中来回复制数据
              直接内存的分配不受java堆大小的限制，但由于是内存，所以肯定受到总内存大小的限制，所以动态扩展时若忽略了直接内存则有可能导致
              OutOfMemoryError异常
              
              
    二、在了解虚拟机运行区的基本构造之后，我们来看看虚拟机一般是怎么工作的。
       (1)对象的创建
              (a)首先我们都知道一般创建对象要用到new关键字，虚拟机遇到一条new指令。
              (b)将new后面带有的参数能否在常量池中定位到一个类的符号引用，常量池是方法区的一部分，存储着类信息(即类的版本、字段、方法、
              接口等描述信息)。检查这个类是否被加载、解析、初始化过，如果没有，则执行相应的类加载过程。
              (c)类加载检查完后，就需要为对象分配内存了，即从堆中划分出一块内存出来分配给对象。
              此时这个划分分配方法根据java内存堆是否规整分成两类:
                    (1)如果java内存堆十分地规整，所有正在用的内存都放在一边，未用过的都放在另一边，那么划分内存只不过是指针的移动
                    这种方法称为“指针碰撞”，老实说这种方法挺难，因为垃圾回收时需要对整体进行移动，
                    (2)如果java的内存堆并不规整，正在用的内存和未使用的内存交错分布，这时不能只是简单地移动指针就能分配内存了。虚拟机
                    必须维护一个列表，记录那块内存能够使用，大小如何，在分配时划出足够大的空间给对象，这种方式成为“空闲列表”
              选择哪种方式取决于内存堆是否规整，而java内存堆是否规整取决于垃圾收集器是否带有压缩整理功能。
              (d)对象的创建划分内存除了确定划给它的区域大小是否足够外，还需要注意一个问题：对象的创建在工程是十分地频繁的，即时是仅仅修改
              指针所指向的位置在高并发的情况下也有可能会出错。即在一个线程正在给A分配内存，指针还没来得及移动，另一个线程给B分配内存，使用了
              原来的指针进行分配，这就不安全了。这是处理方法一般有两种:(1)对分配内存的动作进行同步处理，即分配内存这个动作已经在其作用了，
              另一个线程必须等其这个动作执行完后才能使用这个动作(2)把内存分配的动作按照线程划分在不同空间中进行，即每个线程在java堆中预先
              分配一小块内存，成为本地线程缓存(TLAB)，那个线程要分配内存就在自己的本地线程缓存上分配，其用完了才同步锁定。
              (e)内存分配完后虚拟机需要将分配的内存空间都初始化为零值(不包括对象头),这样可使得对象的实例字段(类名 对象名//这样为声明对象,
              new 构造方法([参数列表]),即给对象分配内存，这样对象才成为类的实例)在java代码中可以不赋初始值就可以直接使用，程序能访问到这
              些字段的数据类型所对应的零值。
              (f)接下来虚拟机对对象进行必要的配置，如这个对象是哪个类的实例，怎样找到类的元数据信息，对象的哈希码、对象的GC分代年龄等信息。
              这些信息存放在对象的对象头（Object Header）之中
              (g)在上面工作都完成后从虚拟机角度对象的创建工作已完成，但是但从Java程序的视角来看，对象创建才刚开始，<init>方法还没有执行，
              所有的字段都还为零。所以一般来说，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的
              对象才算完全产生出来。
              
              总体而言对象的创建步骤如下:虚拟机遇到new指令，检查常量池看类是否被加载，没有则加载，然后给对象分配内存，两种方法“指针碰撞”和
              “空闲列表”，然后虚拟机将所分配的内存空间都初始化为零值，再对对象进行必要的配置，然后一般程序员协定<init>方法初始化对象，如此
              可用的对象才完成。
       (2)对象的内存布局
              对象在内存中的布局可以分成3个部分:对象头、实例数据、对象填充
              (a)对象头:主要包括两部分内容(1)分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、
                                          偏向线程ID、偏向时间戳等
                                       (2)类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
              (b)实例数据:对象真正存储的信息数据。
              (c)对象填充:不是必然存在的，没什么特别地含义，只是起到占位符的作用
       (3)对象的访问定位:建立对象是为了使用对象，通过哪种方式去定位、访问堆中的对象，从而使用对象的实例数据。主要包括两种方法:句柄和直接指针
                       (a)如果使用句柄，首先想一下句柄的含义:可将这一情形想象成用遥控板（句柄）操纵电视机（对象）。只要握住这个遥控板，
                                      就相当于掌握了与电视机连接的通道。
                                      如果使用句柄:如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中
                                      存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
                       (b)如果使用直接指针:如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的
                                         相关信息，而reference中存储的直接就是对象地址。
                       (c)这两种方式各有千秋，使用句柄的最大好处是reference中存储的是稳定的句柄地址，对象被移动(垃圾收集时移动对象是十分普及
                       的行为)，只需改变句柄中的实例数据指针，而reference本身不用修改。
                       使用直接实例的最大好处是速度更快，其节省了一次指针定位的时间开销，由于对象的访问十分频繁，这类开销也十分可观。
    三、内存泄露与内存溢出的区别
        内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它
        存了long才能存下的数，那就是内存溢出。
        内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多
        少内存,迟早会被占光。memory leak会最终会导致out of memory！      
    四、java堆溢出
       不断新建对象，消耗堆内存，当堆内存不够时就会显示OutOfMemory:java heap(堆) space.
       先通过内存影像工具(eclipse memory analyze)对堆存储快照进行分析，看到底是内存溢出还是内存泄露。
       (1)如果是内存泄露，则可以通过工具查看泄露对象到GC roots(Garbage Collector roots,特指垃圾收集器的对象，GC会收集那些不是GC roots且没
       有被GC roots引用的对象)的引用链，于是便可以知道泄露对象通过怎样地路径与GC roots相关联并导致GC无法自动回收它们。掌握了泄露对象的类型
       信息及GC roots引用链的信息，就可以定位泄露代码的位置。
       (2)如果不是内存泄露，那么对象就必须还是活着的，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上
       检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。
    五、虚拟机栈和本地方法栈溢出
       (1)如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出stackoverflowerror异常
       (2)如果虚拟机在扩展栈时无法申请到足够的内存，则抛出outofmemoryerror异常
       但是本质上这两个都是一样东西，内存空间不够了。
       
       虚拟机提供参数控制堆和方法区的最大内存空间，譬如32位windows限制内存为2GB内存，减去Xmx(最大堆容量)和MaxPermSize(最大方法区容量)
       程序计数器几乎不占内存，所以剩余内存被虚拟机栈和本地方法栈瓜分，如果分给每个线程的栈容量越大，那么同时可在用的线程数量就越少，建立
       线程时越容易把剩下的内存耗尽。
       
       如果是建立过多线程导致的内存溢出，再不能减少线程数量的情况下，我们只能减少最大堆和减少分配给每个线程的栈容量来换取更多的线程。
       
    六、方法区和运行时常量池溢出
       运行时常量池溢出:Exception in thread"main"java.lang.OutOfMemoryError：PermGen space
       方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，
       需要特别注意类的回收状况。这类场景除了上面提到的程序使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产
       生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。  
    七、本机直接内存溢出
       Exception in thread"main"java.lang.OutOfMemoryError
       由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，
       而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。
              
              
              
              
              
              
              
              
                  
                   
                 
