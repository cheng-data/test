5.5-2 这时候应该已经涉及了Java的垃圾回收。要留意即使有垃圾回收的情况下也会发生的内存泄露（如自己设计数组容器，元素是引用，逻辑上删除了元素，
但并没有清成null）。注意垃圾回收只能回收内存中的对象，除了内存以外，其它资源不能依靠垃圾回收来关闭。比如，文件、管道、Socket、数据库连接等，
垃圾回收是不会帮你关闭的。
本章内容主要是内存管理和垃圾回收机制参考，参考资料主要为《深入理解java虚拟机》的前三章和部分《java高手真经》。
垃圾回收的内容过多，在5.5步中仅写入关于虚拟机内存的内容，在5.5-2中写入垃圾回收的内容。
一、概述
  首先程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭(敲黑板、划重点啦)
  一般而言栈针随着方法的进入和退出而进行着进栈、出栈动作，每个栈针分配多少内存在类结构确定以后就已知的了，所以程序计数器、虚拟机栈、本地方法栈
  的内存分配和回收都具有确定性，因此方法结束(嗯，方法)或者线程结束时内存也就跟着回收了。
  但是java堆和方法区则不然
  一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道创建了多少对象，
  这部分内存的分配和回收是动态的，垃圾收集器所处理回收的也是对象所占的内存。
二、如何确定对象已经死了
  (1)引用计数法
    嗯，简单理想的方法，但是几乎没有虚拟机会用这种方法判断对象是否已死。
    给对象添加一个引用计数器，每当有一个地方引用它，计数器加1，引用失效时计数器减1，当计数器值为0时此对象不再使用，实现很简单，效率很高。
    但是有一个致命缺点，它很难解决对象之间相互循环引用的问题。
    public Object instance=null；
    private static final int_1MB=1024*1024；
/**
*这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过
*/
    private byte[]bigSize=new byte[2*_1MB]；
    public static void testGC（）{
      ReferenceCountingGC objA=new ReferenceCountingGC（）；
      ReferenceCountingGC objB=new ReferenceCountingGC（）；
      objA.instance=objB；
      objB.instance=objA；
      objA=null；
      objB=null；
//假设在这行发生GC,objA和objB是否能被回收？
      System.gc（）；
    }}
    对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经
    不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。
  (2)可达性分析算法
    主流的判断对象是否死亡的方法。
    基本思想为通过一系列称为“GC Roots”的对象(敲黑板，5.5中提到过:垃圾回收器对象)作为起始点，从这些节点向下探索，搜索走过的路径被称为引用链
    (Reference Chain)(敲黑板，5.5中也提到过)，当一个对象到GC Roots没有任何引用链相连，即对于该对象，GC Roots是不可达的，那么这个对象就是
    不可用的，需要回收的。
    在java中可作为GC Roots的有:
      (a)虚拟机栈(栈针中的本地变量表)中引用的对象
      (b)方法区中类静态属性引用的对象
      (c)方法区中的常量引用的对象
      (d)本地方法栈中native方法引用的对象
三、再谈谈引用
    “引用”这块这个地址写的内容挺好的:http://www.cnblogs.com/yw-ah/p/5830458.html
    上面一直说的例如“常量引用的对象”到底是什么意思，每个名词都明白但连起来就不明白，归根到底动词“引用”没有深入的了解
    引用分为四种:强引用、软引用、弱引用、虚引用4种，引用强度降序排列。
    (a)强引用在程序代码中经常使用，object obj = new object();
    而这样 obj对象对后面new Object的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。
    当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
    如果不使用时，要通过如下方式来弱化引用，如下：obj = null;显式地设置obj为null，或超出对象的生命周期范围，则gc认为该对象不
    存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。
    (b)软引用
    用来描述一些还有用但并非必需的对象，对于软引用关联的对象，在系统将要发生内存溢出异常之前(敲黑板，此时内存已经不够了，
    要抛出内存溢出异常啦，回收这部分内存)，此时将对象列入回收范围中进行第二次回收。
    如果回收之后内存还不够，就会抛出内存溢出异常。采用SoftReference类来实现软引用。
    Object obj = new Object();
    SoftReference<Object> sf = new SoftReference<Object>(obj);
    obj = null;
    sf.get();//有时候会返回null
    这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；
    软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；
    当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。
    (c)弱引用
    用来描述非必须对象，它强度比软引用要弱一些，被弱引用关联的对象只能生存到下一次垃圾收集之前，当垃圾收集器工作时无论当前内存是否够用
    被弱引用关联的对象都要被回收。使用WeakReference类来实现弱引用。
    Object obj = new Object();
    WeakReference<Object> wf = new WeakReference<Object>(obj);
    obj = null;
    wf.get();//有时候会返回null
    wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾
    弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。
    弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。
    (d)虚引用
    最弱的一种引用关系，一个对象是否有虚引用对其一点影响都没有，不会对其生存空间产生影响，也无法通过虚引用得到对象实例，为一个对象
    设置虚引用的目的是能在这个对象被回收时收到系统通知。
    提供了PhantomReference类来实现虚引用
    ReferenceQueue queue = new ReferenceQueue ();
    PhantomReference pr = new PhantomReference (object, queue); 
四、回收方法区
  其实很多人认为方法区是没有垃圾回收的，因为方法区是所有线程共享的区域，存储着类信息，常量，静态变量等等，即编译后的代码、数据等。
  也因此方法区的回收效率很低，回收了也回收不了太大的空间。
  一般来说方法区回收的主要包括两部分内容:废弃的常量和无用的类。回收废弃的常量与回收堆中的对象差不多，比如说如果当前系统中没有
  一个String对象叫做“abc”的，即没有一个String对象引用常量池中的“abc”常量，其他地方也没有引用到这个常量，垃圾回收时如果有必要，这个“abc”常量
  会被清除出常量池。
  但是需要注意的是判断一个常量为废弃常量很简单，没有对象引用它即可，但是判断类是否是无用的类则十分地苛刻。需要同时满足下面3个条件才行。
  (a)该类的所有实例都被回收，即java堆中不存在该类的实例(对象)。
  (b)加载该类的ClassLoader已经被回收
  (c)该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
  所以说回收类的条件十分地苛刻。
五、垃圾回收算法
  (1)标记-清除算法
    算法分为两个阶段:“标记”和“清除”。首先标记处所有需要被回收的对象，标记完成后统一回收所有被标记的对象。标记过程就是之前的可达性分析算法中
    判定与GC roots之间没有引用链连接的对象。
    这个方法是最基本的算法，后面的算法都基于它，但是这个算法有两个明显地不足:(a)第一个是效率问题，标记过程和清除过程效率都不高(b)另一个是空间
    问题，标记清除后悔产生大量不连续的内存碎片，空间碎片过多会导致后续为某一对象分配较大内存的时候没有足够大的连续的(嗯，重点，连续的)内存空间
    从而触发另一次垃圾回收。
  (2)复制算法
    它将可用内存按容量划分为大小相等的两块，每次只使用一块，当这一块内存使用完了，就将还活着的对象复制到另一块上，然后把已用的那一块内存空间
    清除掉，这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，
    运行高效。
    但是这种方法代价巨大：本质可用的内存为总内存的一半，嗯，代价不小。
    现在的商业虚拟机都采用这种收集算法来回收新生代(嗯，新生代和老年代，需要注意一下)，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，
    所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。
    当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟
    机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。
  (3)标记-整理算法
    复制收集算法在对象存活率较高的情况下效率并不高，因为其需要较多的复制操作，更关键的
    是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中
    所有对象都100%存活的极端情况，所以在老年代中一般不能直接使用复制算法
    根据老年代的特点，有人提出了标记-整理算法，标记过程与“标记-清除”中的标记过程一致，标记完后不是直接对可回收对象进行清理，而是让所有存活的
    对象都向一端移动，然后清理掉端边界以外的内存
  (4)分代-收集算法
    没什么新意，将java堆分块，一般分为新生代和老年代，因为新生代每次垃圾回收时都会有大批对象死去，对于这部分采用复制算法，对于老年代，因为对象
    生存率高，没有额外空间担保，所以采用“标记-整理”或者“标记-清除”算法。
  (5)新生代和老年代
    在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个
    区域：Eden、From Survivor、To Survivor。
    ---------------------          ----------
    | eden  | from | to  |         |        |
    |       |      |     |         |        |
    | 8/10  |1/10  | 1/10|         |        |
    新生代: 堆的1/3                   老年代:堆的2/3
    
    新生代:新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中
    的大部分对象通常不需长久存活，具有朝生夕灭的性质。
    老年代:年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 "死掉" 了的。
    java的堆是GC收集垃圾的主要区域,GC分为两种:Minor GC、Full GC ( 或称为 Major GC )。
    Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。
    Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法或者标记-整理算法
    因为老年代中的对象不那么容易死去，因此Full GC发生的次数不会像Minor GC那样频繁，而且做一次Full GC所花时间比Minor GC要长。
    除此以外，如果老年代中采用标记-清除算法，垃圾回收后会留下大量不连续的内存碎片，如果在给某个对象分配内存时没有足够大的空间，那么
    会引发又一次的垃圾回收。

六、HotSpot虚拟机中垃圾判定的算法实现。
  (1)枚举根节点
    从可达性分析中从GC Roots节点找引用链这个操作为例，一般可作为GC Roots的节点主要在全局性应用(例如常量和类静态属性)与执行上下文(栈针中
    的本地变量表)中，但是如今很多应用仅方法区就几百兆，逐个检查里面的索引必然消耗很多的时间。
    另外，可达性分析对执行时间的敏感还体现在GC停顿上，在整个可达性分析期间，整个执行系统必须看起来像是被冻结在某个时间点上，不可以出现分析
    过程中对象引用关系还在不断变化的情况，这个要求不满足的话无法保证分析结果的准确性。
    因为这个原因，在GC过程中必须停顿所有java执行线程。
    目前主流的java虚拟机使用的都是准确式GC，在整个系统停顿期间，并不需要一个不漏地检查完所有全局性应用和执行上下文的引用位置，虚拟机有办法
    直接得知哪些地方存放着对象引用。
    在HotSpot中用一个名为OopMap的数据结构来达到这个目的。在类加载完成的时候(类的加载:虚拟机把描述类的数据从class文件加载到内存，并对数据
    进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。)HotSpot就把对象内什么偏移量上什么类型的
    数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。
    OopMap例子:
      可以看到在0x026eb7a9处的call指令有OopMap记录，它指明了EBX寄存器和栈中偏移量为16的内存区域中各有一个普通对象指针（Ordinary Object 
      Pointer）的引用，有效范围为从call指令开始直到0x026eb730（指令流的起始位置）+142（OopMap记录的偏移量）=0x026eb7be，即hlt指令为止。
  (2)安全点
    在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但是有一个问题:说OopMap内容变化的指令非常多，如果为每一
    条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。
    HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序
    执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频
    繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定
    
    对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。
    两种方法:：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），其中抢先式中断不需要线程的执行代码主动去配合，
    在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢
    先式中断来暂停线程从而响应GC事件。而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时
    主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方
  (3)安全区域
    Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配
    CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太
    可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。安全区域是指在一段代码片段之中，引用关系不会发生
    变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。
七、垃圾收集器
  各种垃圾收集器指标
八、内存分配与回收策略
  对象的内存分配，往大方向讲，就是在堆上分配。对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。
  少数情况下也可能会直接分配在老年代中，具体分配情况根据实际的虚拟机而定。
  
  下面几条内存分配原则:
    (1)对象优先在Eden分配
    (2)大对象直接进入老年代
      所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组,大对象对虚拟机
      的内存分配来说就是一个坏消息,经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。
    (3)长期存活的对象将进入老年代
      分代收集的思想
    (4)动态对象年龄判定
      为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，
      如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等
      到MaxTenuringThreshold中要求的年龄。
  九、空间分配担保
    在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保
    是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续
    空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或
    者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。
    
    风险:新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的
    情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代
    
    
